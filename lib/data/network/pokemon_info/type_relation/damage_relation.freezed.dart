// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'damage_relation.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$DamageRelation {
  List<TypeRelation> get noDamageTo => throw _privateConstructorUsedError;
  List<TypeRelation> get halfDamageTo => throw _privateConstructorUsedError;
  List<TypeRelation> get doubleDamageTo => throw _privateConstructorUsedError;
  List<TypeRelation> get noDamageFrom => throw _privateConstructorUsedError;
  List<TypeRelation> get halfDamageFrom => throw _privateConstructorUsedError;
  List<TypeRelation> get doubleDamageFrom => throw _privateConstructorUsedError;

  /// Create a copy of DamageRelation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DamageRelationCopyWith<DamageRelation> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DamageRelationCopyWith<$Res> {
  factory $DamageRelationCopyWith(
          DamageRelation value, $Res Function(DamageRelation) then) =
      _$DamageRelationCopyWithImpl<$Res, DamageRelation>;
  @useResult
  $Res call(
      {List<TypeRelation> noDamageTo,
      List<TypeRelation> halfDamageTo,
      List<TypeRelation> doubleDamageTo,
      List<TypeRelation> noDamageFrom,
      List<TypeRelation> halfDamageFrom,
      List<TypeRelation> doubleDamageFrom});
}

/// @nodoc
class _$DamageRelationCopyWithImpl<$Res, $Val extends DamageRelation>
    implements $DamageRelationCopyWith<$Res> {
  _$DamageRelationCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DamageRelation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? noDamageTo = null,
    Object? halfDamageTo = null,
    Object? doubleDamageTo = null,
    Object? noDamageFrom = null,
    Object? halfDamageFrom = null,
    Object? doubleDamageFrom = null,
  }) {
    return _then(_value.copyWith(
      noDamageTo: null == noDamageTo
          ? _value.noDamageTo
          : noDamageTo // ignore: cast_nullable_to_non_nullable
              as List<TypeRelation>,
      halfDamageTo: null == halfDamageTo
          ? _value.halfDamageTo
          : halfDamageTo // ignore: cast_nullable_to_non_nullable
              as List<TypeRelation>,
      doubleDamageTo: null == doubleDamageTo
          ? _value.doubleDamageTo
          : doubleDamageTo // ignore: cast_nullable_to_non_nullable
              as List<TypeRelation>,
      noDamageFrom: null == noDamageFrom
          ? _value.noDamageFrom
          : noDamageFrom // ignore: cast_nullable_to_non_nullable
              as List<TypeRelation>,
      halfDamageFrom: null == halfDamageFrom
          ? _value.halfDamageFrom
          : halfDamageFrom // ignore: cast_nullable_to_non_nullable
              as List<TypeRelation>,
      doubleDamageFrom: null == doubleDamageFrom
          ? _value.doubleDamageFrom
          : doubleDamageFrom // ignore: cast_nullable_to_non_nullable
              as List<TypeRelation>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DamageRelationImplCopyWith<$Res>
    implements $DamageRelationCopyWith<$Res> {
  factory _$$DamageRelationImplCopyWith(_$DamageRelationImpl value,
          $Res Function(_$DamageRelationImpl) then) =
      __$$DamageRelationImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<TypeRelation> noDamageTo,
      List<TypeRelation> halfDamageTo,
      List<TypeRelation> doubleDamageTo,
      List<TypeRelation> noDamageFrom,
      List<TypeRelation> halfDamageFrom,
      List<TypeRelation> doubleDamageFrom});
}

/// @nodoc
class __$$DamageRelationImplCopyWithImpl<$Res>
    extends _$DamageRelationCopyWithImpl<$Res, _$DamageRelationImpl>
    implements _$$DamageRelationImplCopyWith<$Res> {
  __$$DamageRelationImplCopyWithImpl(
      _$DamageRelationImpl _value, $Res Function(_$DamageRelationImpl) _then)
      : super(_value, _then);

  /// Create a copy of DamageRelation
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? noDamageTo = null,
    Object? halfDamageTo = null,
    Object? doubleDamageTo = null,
    Object? noDamageFrom = null,
    Object? halfDamageFrom = null,
    Object? doubleDamageFrom = null,
  }) {
    return _then(_$DamageRelationImpl(
      noDamageTo: null == noDamageTo
          ? _value._noDamageTo
          : noDamageTo // ignore: cast_nullable_to_non_nullable
              as List<TypeRelation>,
      halfDamageTo: null == halfDamageTo
          ? _value._halfDamageTo
          : halfDamageTo // ignore: cast_nullable_to_non_nullable
              as List<TypeRelation>,
      doubleDamageTo: null == doubleDamageTo
          ? _value._doubleDamageTo
          : doubleDamageTo // ignore: cast_nullable_to_non_nullable
              as List<TypeRelation>,
      noDamageFrom: null == noDamageFrom
          ? _value._noDamageFrom
          : noDamageFrom // ignore: cast_nullable_to_non_nullable
              as List<TypeRelation>,
      halfDamageFrom: null == halfDamageFrom
          ? _value._halfDamageFrom
          : halfDamageFrom // ignore: cast_nullable_to_non_nullable
              as List<TypeRelation>,
      doubleDamageFrom: null == doubleDamageFrom
          ? _value._doubleDamageFrom
          : doubleDamageFrom // ignore: cast_nullable_to_non_nullable
              as List<TypeRelation>,
    ));
  }
}

/// @nodoc

class _$DamageRelationImpl
    with DiagnosticableTreeMixin
    implements _DamageRelation {
  const _$DamageRelationImpl(
      {required final List<TypeRelation> noDamageTo,
      required final List<TypeRelation> halfDamageTo,
      required final List<TypeRelation> doubleDamageTo,
      required final List<TypeRelation> noDamageFrom,
      required final List<TypeRelation> halfDamageFrom,
      required final List<TypeRelation> doubleDamageFrom})
      : _noDamageTo = noDamageTo,
        _halfDamageTo = halfDamageTo,
        _doubleDamageTo = doubleDamageTo,
        _noDamageFrom = noDamageFrom,
        _halfDamageFrom = halfDamageFrom,
        _doubleDamageFrom = doubleDamageFrom;

  final List<TypeRelation> _noDamageTo;
  @override
  List<TypeRelation> get noDamageTo {
    if (_noDamageTo is EqualUnmodifiableListView) return _noDamageTo;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_noDamageTo);
  }

  final List<TypeRelation> _halfDamageTo;
  @override
  List<TypeRelation> get halfDamageTo {
    if (_halfDamageTo is EqualUnmodifiableListView) return _halfDamageTo;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_halfDamageTo);
  }

  final List<TypeRelation> _doubleDamageTo;
  @override
  List<TypeRelation> get doubleDamageTo {
    if (_doubleDamageTo is EqualUnmodifiableListView) return _doubleDamageTo;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_doubleDamageTo);
  }

  final List<TypeRelation> _noDamageFrom;
  @override
  List<TypeRelation> get noDamageFrom {
    if (_noDamageFrom is EqualUnmodifiableListView) return _noDamageFrom;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_noDamageFrom);
  }

  final List<TypeRelation> _halfDamageFrom;
  @override
  List<TypeRelation> get halfDamageFrom {
    if (_halfDamageFrom is EqualUnmodifiableListView) return _halfDamageFrom;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_halfDamageFrom);
  }

  final List<TypeRelation> _doubleDamageFrom;
  @override
  List<TypeRelation> get doubleDamageFrom {
    if (_doubleDamageFrom is EqualUnmodifiableListView)
      return _doubleDamageFrom;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_doubleDamageFrom);
  }

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'DamageRelation(noDamageTo: $noDamageTo, halfDamageTo: $halfDamageTo, doubleDamageTo: $doubleDamageTo, noDamageFrom: $noDamageFrom, halfDamageFrom: $halfDamageFrom, doubleDamageFrom: $doubleDamageFrom)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'DamageRelation'))
      ..add(DiagnosticsProperty('noDamageTo', noDamageTo))
      ..add(DiagnosticsProperty('halfDamageTo', halfDamageTo))
      ..add(DiagnosticsProperty('doubleDamageTo', doubleDamageTo))
      ..add(DiagnosticsProperty('noDamageFrom', noDamageFrom))
      ..add(DiagnosticsProperty('halfDamageFrom', halfDamageFrom))
      ..add(DiagnosticsProperty('doubleDamageFrom', doubleDamageFrom));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DamageRelationImpl &&
            const DeepCollectionEquality()
                .equals(other._noDamageTo, _noDamageTo) &&
            const DeepCollectionEquality()
                .equals(other._halfDamageTo, _halfDamageTo) &&
            const DeepCollectionEquality()
                .equals(other._doubleDamageTo, _doubleDamageTo) &&
            const DeepCollectionEquality()
                .equals(other._noDamageFrom, _noDamageFrom) &&
            const DeepCollectionEquality()
                .equals(other._halfDamageFrom, _halfDamageFrom) &&
            const DeepCollectionEquality()
                .equals(other._doubleDamageFrom, _doubleDamageFrom));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_noDamageTo),
      const DeepCollectionEquality().hash(_halfDamageTo),
      const DeepCollectionEquality().hash(_doubleDamageTo),
      const DeepCollectionEquality().hash(_noDamageFrom),
      const DeepCollectionEquality().hash(_halfDamageFrom),
      const DeepCollectionEquality().hash(_doubleDamageFrom));

  /// Create a copy of DamageRelation
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DamageRelationImplCopyWith<_$DamageRelationImpl> get copyWith =>
      __$$DamageRelationImplCopyWithImpl<_$DamageRelationImpl>(
          this, _$identity);
}

abstract class _DamageRelation implements DamageRelation {
  const factory _DamageRelation(
          {required final List<TypeRelation> noDamageTo,
          required final List<TypeRelation> halfDamageTo,
          required final List<TypeRelation> doubleDamageTo,
          required final List<TypeRelation> noDamageFrom,
          required final List<TypeRelation> halfDamageFrom,
          required final List<TypeRelation> doubleDamageFrom}) =
      _$DamageRelationImpl;

  @override
  List<TypeRelation> get noDamageTo;
  @override
  List<TypeRelation> get halfDamageTo;
  @override
  List<TypeRelation> get doubleDamageTo;
  @override
  List<TypeRelation> get noDamageFrom;
  @override
  List<TypeRelation> get halfDamageFrom;
  @override
  List<TypeRelation> get doubleDamageFrom;

  /// Create a copy of DamageRelation
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DamageRelationImplCopyWith<_$DamageRelationImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
